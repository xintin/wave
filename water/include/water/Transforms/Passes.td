// Copyright 2025 The Wave Authors
//
// Licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef WATER_PASSES
#define WATER_PASSES

include "mlir/Pass/PassBase.td"

def WaterAssertInBoundsPass : Pass<"water-assert-in-bounds"> {
  let summary = "Insert assertions that memref accesses are in bounds.";
  let description = [{
    Insert assertions (`cf.assert`) checking whether an access through a memref
    will not be accessing out-of-bounds. In particular, emit code comparing the
    i-th subscript, s_i, of each read/write operation as 0 <= s_i < dim_i where
    dim_i is the size of the memref in the i-th dimension. If `checkEachDim`
    set, a separate assertion is generated for each dimension, otherwise, a
    common condition is generated by conjunction.

    If `includeVectorLoadStore` is set, also perform checks for operations from
    the vector dialect, such as `vector.load`/`store`. The semantics of these
    operations specifically allow for out-of-bounds reads, the flag forces the
    check to override these semantics and insert assertions anyway.

    If `waveOnUnknown` is set, emit a warning when the input IR contains an
    operation that declares having side effects but is not known to the pass
    at the moment. No assertion logic will be generated for such operations.

    `createSpeculativeFuncs` moves the generated assertions into a separate
    function instead of interleaving them with the original IR. Thus the
    speculative function can be called before the main function, which is
    practical in cases where the main function is excessively long or executes
    on a device where memory errors are difficult to identify (such as a GPU) or
    where the assertion or another trapping mechanism is not easily accessible.
    Such functions accept the same operands as the main function, but only
    actually read the data if it used as addresses in indirect memory access
    operations, such as indirect loads or gathers. Speculative functions may
    fail to be generated when they would require invalid speculation, i.e.,
    executing a side-effecting operation where such side effects could alter
    the subsequent execution of the main function, such as writing back to
    memory.

    A call to the speculative function is inserted as the first operation in the
    main function. Subsequent passes (or future variations of this pass) may
    hoist this function call and ensure the read input data are available on the
    resource where the speculative function is slated for execution.

    Generated assertions use base upstream MLIR dialects and can be readily
    simplified by canonicalization and CSE.
  }];

  let dependentDialects = [
    "arith::ArithDialect",
    "cf::ControlFlowDialect",
    "memref::MemRefDialect",
  ];
  let options = [
    Option<"warnOnUnknown", "warn-on-unknown", "bool", /*default=*/"true",
      "Warn on unknown side-effecting operations">,
    Option<"includeVectorLoadStore", "include-vector-load-store", "bool",
      /*default=*/"false",
      "Include vector.load/store operations despite them allowing "
      "out-of-bounds">,
    Option<"checkEachDim", "check-each-dim", "bool", /*default=*/"true",
      "Check each dimension individually">,
    // TODO: consider making this a separate pass as it has to operate at
    // module level.
    Option<"createSpeculativeFuncs", "create-speculative-funcs", "bool",
      /*default=*/"false",
      "Create a function that performs assertions speculatively instead of "
      "in-place checks">
  ];
}

def WaterCheckStaticAssertionsPass : Pass<"water-check-static-assertions"> {
  let summary = "Fail if the IR contains a known-false assertion.";
  let description = [{
    Traverses the IR and fails the pass, and consequently the pass pipeline,
    if it contains a known-false assertion. Only detects assertions with
    constant "false" condition, **does not** perform any simplification, which
    should be performed by dedicated passes previously.
  }];
}

def WaterGreedySLPVectorizer : Pass<"water-greedy-slp-vectorizer"> {
  let summary = "SLP Vectorizer Pass";
  let description = [{
    This pass implements the SLP (Superword Level Parallelism) vectorizer.
    It detects consecutive operations that can be put together into vector
    operations. The pass works bi-directionaly, starting from reads or stores,
    in search of scalars to combine.

    This is greedy vectorizer, it doesn't have any cost model (yet) and it tries
    to create vector ops if we have at least 2 potential ops.
  }];
  let dependentDialects = ["mlir::vector::VectorDialect"];

  let options = [
    Option<"maxVectorBitwidth", "max-vector-bitwidth", "unsigned",
      /*default=*/"std::numeric_limits<unsigned>::max()",
      "Maximum supported vector bitwidth">,
  ];
}

def WaterGPUToGPURuntime : Pass<"water-gpu-to-gpu-runtime", "::mlir::ModuleOp"> {
  let summary = "Lower GPU dialect ops to runtime calls";
  let description = [{
    This pass lowers operations from the GPU dialect to calls into GPU runtime
    functions.
  }];
  let dependentDialects = ["::mlir::LLVM::LLVMDialect"];
}

#endif // WATER_PASSES
